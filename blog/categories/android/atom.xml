<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Paris Blog]]></title>
  <link href="http://pyeh.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://pyeh.github.io/"/>
  <updated>2013-12-02T21:11:31+08:00</updated>
  <id>http://pyeh.github.io/</id>
  <author>
    <name><![CDATA[Han-Chun Yeh (Paris)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[intel_mid: Introduction of android watchdogs and kernel watchdogs]]></title>
    <link href="http://pyeh.github.io/blog/2013/12/02/intel-mid-introduction-of-android-watchdog-and-kernel-watchdog/"/>
    <updated>2013-12-02T17:29:00+08:00</updated>
    <id>http://pyeh.github.io/blog/2013/12/02/intel-mid-introduction-of-android-watchdog-and-kernel-watchdog</id>
    <content type="html"><![CDATA[<p>Watchdogs monitor software and hardware device and prevent whole system from hanging.</p>

<h2>1. Android framework&rsquo;s Java* watchdog</h2>

<p>Deal with cases when any of the following locks is held for more than a minute or when ServerThread is busy.</p>

<p>&mdash;ThermalManagerService<br/>
&mdash;PowerManagerService<br/>
&mdash;WindowMangerService<br/>
&mdash;MountService<br/>
&mdash;NetworkManagementService<br/>
&mdash;ActivityMangerService</p>

<p>If one of above services hangs for one minute, the java watchdog kills it and results in restarting android&rsquo;s framework by killing the SystemServer.</p>

<h2>2. Device-critical services</h2>

<p>Critical services are declared as &ldquo;critical&rdquo; in the corresponding rc files. (eg, ueventd, servicemanager) If critical services exist or crash more than four times in four minutes, the device will reboot into recovery mode. This feature is handled by the init process.</p>

<h2>3. Kernel watchdog leads to COLD_RESET</h2>

<p>The kernel wathcdog prvents the operating system from haning. The System Control Unit (SCU firmware) resets the platform when the kernel cannot schedule the watchdog daemon (/usr/bin/ia_watchdogd).</p>

<p>The driver located at /drivers/watchdog/intel_scu_watchdog_evo.c provides a /dev/watchdog device to access the kernel watchdog and ioctls to configure the timer. Since the SCU provides the functionality, all access to watchdog features are routed to the SCU via an IPC (see more PIC regitration at arch/x86/platform/intel-mid/intel_mid_scu.c)</p>

<h2>4. Userspace watchdog daemon</h2>

<p>Source codes are located at /hardware/ia_watchdog/watchdog_daemon folder) and target location is /usr/bin/ia_watchdogd. This daemon is declared as one-shot service in the rc file (init.watchdog.rc) and perform the following steps:</p>

<p>&mdash;open the watchdog device /dev/watchdog.<br/>
&mdash;configure the pre_timeout with 75 and timeout with 90.<br/>
&mdash;Loop forever. In the loop, kick the watchdog device (by writing to &lsquo;R&rsquo; to /dev/watchdog) every 60 seconds.</p>

<h2>5. SCU watchdog leads to PLATFORM_RESET(deep reset)</h2>

<p>This prevents the platform stucking on SCU by issuing a PLATFORM_RESET because the interface between the SCU and PMIC is broken.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[intel_mid: Overview of Simple Platform Interface]]></title>
    <link href="http://pyeh.github.io/blog/2013/11/27/intel-mid-overview-of-simple-platform-interface/"/>
    <updated>2013-11-27T15:40:00+08:00</updated>
    <id>http://pyeh.github.io/blog/2013/11/27/intel-mid-overview-of-simple-platform-interface</id>
    <content type="html"><![CDATA[<p>Start to develop android kernel under X86 MID platform, merrifield.
I am a newbie for porting kernel to Atom-based platform but am familiar with linux kernel and device drivers.
Noticed that Intel Android BSP introudes Simple Firmware Interface (SFI) a method for platform firmware to export
static tables (I2C, SPI, GPIO) to the operation system.</p>

<p>Intel&rsquo;s newer Atom processors support SFI since &ldquo;Moorestown&rdquo; SoC and SFI implementation was merged into upstream kernel 2.6.32(<a href="http://lwn.net/Articles/340476">http://lwn.net/Articles/340476</a>)</p>

<p>Actually, below link descrbies the SFI and explains how does SFI related to ACPI and UEFI.
<a href="https://simplefirmware.org/faq">https://simplefirmware.org/faq</a></p>

<p>Besides, below patch sets are to refactor existing code and implement a flexible way to support multiple boards and devices.
<a href="https://lkml.org/lkml/2013/10/10/81">https://lkml.org/lkml/2013/10/10/81</a></p>

<p>/arch/x86/platform/intel-mid/intel_mid_sfi.c is SFI parsing implementation, and let me understand how get_gpio_by_name() works.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ram-console upstreaming]]></title>
    <link href="http://pyeh.github.io/blog/2013/11/08/android-ram-console-upstreaming/"/>
    <updated>2013-11-08T17:45:00+08:00</updated>
    <id>http://pyeh.github.io/blog/2013/11/08/android-ram-console-upstreaming</id>
    <content type="html"><![CDATA[<p>While dealing with board bring-up powered by Tegra5, starts to aware of this upstream change for ram console (aka /proc/last_kmsg). A working group, Android Upstreaming, comes from Linaro foundation to merge ram_console into pstore framework ( <a href="http://lwn.net/Articles/497881/">http://lwn.net/Articles/497881/</a>).</p>

<p>The Android Upstreaming team&rsquo;s mission is to reduce and eventually eliminate the differences between the upstream kernel and the Android kernel. The team works closely with Google and upstream kernel developers to find ways to implement Android required features in a way that meets the need of both communities.</p>

<p>There are currently two competing debug facilities to store kernel messages in a persistent storage: a generic pstore and Google&rsquo;s persistent_ram by Colin Cross. Not so long ago (<a href="https://lkml.org/lkml/2012/3/8/252">https://lkml.org/lkml/2012/3/8/252</a>) noticed by Greg KH@ARM Linux, it was decided to fix this situation. There is a buleprint registered by Linaro Linux to descrbie those debug facilities at <a href="https://blueprints.launchpad.net/linux-linaro/+spec/android-ram-console">https://blueprints.launchpad.net/linux-linaro/+spec/android-ram-console</a></p>

<p>To follow up android upstreaming&rsquo;s works, I remove legacy driver supporting for ram console and persistent ram and switch new pstore framework. In other words, start to looking into /sys/fs/pstore/console-ramoops as we used to did analysis on /proc/last_kmsg for dying moment across system reboot.</p>

<p>My works were merged into Asus internal development branch jb-mr2-t50-k3.10, but not opened yet. We could refer to <a href="https://android.googlesource.com/kernel/tegra/+/android-tegra-3.10">https://android.googlesource.com/kernel/tegra/+/android-tegra-3.10</a> for further reference.</p>
]]></content>
  </entry>
  
</feed>
